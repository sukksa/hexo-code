---
title: 变量解构赋值
date: 2021-11-6 13:57:08
tags:
 - ES6
 - javaScript
categories: ES6
---

# 变量的解构赋值 #

ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。
<!-- more -->
## 数组的解构赋值 ##

        const ARR = ["1", "2", "3"]
        let [a, b, c] = ARR
		//等价于 let [a, b, c] = ["1", "2", "3"]
        console.log(a, b, c) // 1 2 3 
上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。

本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

下面是一些使用嵌套数组进行解构的例子

        let [, , third] = ["foo", "bar", "baz"]
        console.log(third) // "baz"

        let [x, , y] = [1, 2, 3]
        console.log(x) // 1
        console.log(y) // 3
		
		// ...x 为匹配剩余项
        let [head, ...tail] = [1, 2, 3, 4]
        console.log(head) // 1
        console.log(tail) // [2, 3, 4]

        let [x, y, ...z] = ["a"]
        console.log(x) // "a"
        console.log(y) // undefined
        console.log(z) // []

如果解构不成功，变量的值就等于undefined。

		let [foo] = []
		let [bar, foo] = [1]
		// foo的值都为undefined

解构赋值允许指定默认值。 

		let [foo = true] = []
		console.log(foo) // true
		
		let [x, y = "b"] = ["a"]; // x='a', y='b'
		let [x, y = "b"] = ["a", undefined]; // x='a', y='b'
注意，ES6 内部使用严格相等运算符(===)，判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 

		let [x = 1] = [undefined]
		console.log(x) // 1
		
		let [y = 1] = [null];
		console.log(y) // null

## 对象的解构赋值 ##

        const obj = {
            name: "tom",
            age: 18,
            fun: function () {
                console.log("i am tom")
            }
        }
        let {name, age, fun} = obj
        console.log(name, age, fun) // tom 18 function()
		fun() // i am tom

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值，否则为undefined

		let {age, sex} = obj
	    console.log(age, sex) //18 undefined

如果变量名与属性名不一致，必须写成下面这样:

        let { foo: baz } = { foo: "aaa", bar: "bbb" };
        console.log(baz) // aaa
		console.log(foo) //Uncaught ReferenceError: foo is not defined
	
也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量，即 `foo` 是匹配的模式， `baz` 才是变量。真正被赋值的是变量 `baz` ，而不是模式 `foo`

对象的解构也可以指定默认值,默认值生效的条件是，对象的属性值严格等于`undefined`

		let { x = 3 } = {}
		console.log(x) // 3
		
		let { x, y = 5 } = { x: 1 }
		console.log(x) // 1
		console.log(y) // 5
		
		let { x: y = 3 } = { x: 5 }
		console.log(y) // 5



如果解构失败，变量的值等于undefined。

		let { foo } = { bar: "baz" }
		console.log(foo) // undefined


## 字符串的解构赋值 ##
字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象

        let [a, b, c, d, e] = "hello"
        console.log(a, b, c, d, e) // h e l l o

类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。

        let {length} = "hello
        console.log(length) //5

## 数值和布尔值的解构赋值 ##
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

		let {toString: s} = 123
		s === Number.prototype.toString // true
		
		let {toString: s} = true
		s === Boolean.prototype.toString // true

上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

		let { prop: x } = undefined // TypeError
		let { prop: y } = null // TypeError



## 函数参数的解构赋值 ##

函数的参数也可以使用解构赋值

		function add([x, y]){
		  return x + y
		}
		
		add([1, 2]) // 3
		
		[[1, 2], [3, 4]].map(([a, b]) => a + b)	// [ 3, 7 ]

上面代码中，函数`add()`的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量`x`和`y`。对于函数内部的代码来说，它们能感受到的参数就是`x`和`y`

函数参数的解构也可以使用默认值

		function move({x = 0, y = 0} = {}) {
		  return [x, y]
		}
		
		move({x: 3, y: 8});// [3, 8]
		move({x: 3}) // [3, 0]
		move({}) // [0, 0]
		move() // [0, 0]

下面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果`undefined`就会触发函数参数的默认值

		function move({x, y} = { x: 0, y: 0 }) {
		  return [x, y]
		}
		
		move({x: 3, y: 8}) // [3, 8]
		move({x: 3}) // [3, undefined]
		move({}) // [undefined, undefined]
		move() // [0, 0]
		
		[1, undefined, 3].map((x = 'yes') => x)// [ 1, 'yes', 3 ]